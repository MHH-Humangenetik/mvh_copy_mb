<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>MeldebestÃ¤tigungen Viewer</title>

    <!-- Milligram CSS -->
    <link rel="stylesheet" href="https://unpkg.com/milligram@1.4.1/dist/milligram.min.css">

    <!-- Custom RosÃ© Pine CSS -->
    <link rel="stylesheet" href="/static/css/custom.css">

    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10" defer></script>

    <!-- Alpine.js -->
    <script src="https://unpkg.com/alpinejs@3.13.3" defer></script>
</head>

<body>
    <div class="container" x-data="tableData()">
        <div class="header-container">
            <h1>MeldebestÃ¤tigungen Viewer</h1>
            <div id="connection-status" class="connection-status connecting">Connecting...</div>
        </div>

        <!-- Loading indicator -->
        <div id="loading" class="htmx-indicator">
            <p>Loading...</p>
        </div>

        {% if error_message %}
        <div class="error-message">
            <p><strong>Error:</strong> {{ error_message }}</p>
        </div>
        {% else %}

        <!-- JavaScript required notice (hidden when JS is available) -->
        <noscript>
            <div class="noscript-notice">
                <h2>JavaScript Required</h2>
                <p>This application requires JavaScript to function properly. Please enable JavaScript in your browser to view and interact with the MeldebestÃ¤tigungen data.</p>
                <p>Features that require JavaScript include:</p>
                <ul>
                    <li>Data table display and rendering</li>
                    <li>Real-time filtering and search</li>
                    <li>Column sorting</li>
                    <li>Statistics display</li>
                    <li>Done status updates</li>
                </ul>
            </div>
        </noscript>

        <!-- Main application content (requires JavaScript) -->
        <div class="js-required-content">
            <!-- Filter input and Statistics -->
            <div class="filter-and-stats-container">
                <div class="filter-container">
                    <label for="filter">Filter:</label>
                    <input type="text" id="filter" x-model="filter" placeholder="Search across all columns..."
                        class="filter-input">
                </div>
                
                <!-- Statistics display -->
                <div class="statistics-container">
                    <div class="statistics-item">
                        <span class="statistics-label">Total Cases:</span>
                        <span class="statistics-value" x-text="totalCases || '--'">--</span>
                    </div>
                    <div class="statistics-item">
                        <span class="statistics-label">Ready:</span>
                        <span class="statistics-value" x-text="readyPairs || '--'">--</span>
                    </div>
                    <div class="statistics-item">
                        <span class="statistics-label">Done:</span>
                        <span class="statistics-value" x-text="donePairs || '--'">--</span>
                    </div>
                </div>
            </div>

            <!-- Table -->
            <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th @click="sortBy('case_id')" class="sortable">
                            Case ID
                            <span x-show="sortColumn === 'case_id'">
                                <span x-show="sortDirection === 'asc'">â–²</span>
                                <span x-show="sortDirection === 'desc'">â–¼</span>
                            </span>
                        </th>
                        <th>Vorgangsnummer</th>
                        <th>IBE String</th>
                        <th>Art der Daten</th>
                        <th @click="sortBy('typ_der_meldung')" class="sortable">
                            Typ der Meldung
                            <span x-show="sortColumn === 'typ_der_meldung'">
                                <span x-show="sortDirection === 'asc'">â–²</span>
                                <span x-show="sortDirection === 'desc'">â–¼</span>
                            </span>
                        </th>
                        <th @click="sortBy('indikationsbereich')" class="sortable">
                            Indikationsbereich
                            <span x-show="sortColumn === 'indikationsbereich'">
                                <span x-show="sortDirection === 'asc'">â–²</span>
                                <span x-show="sortDirection === 'desc'">â–¼</span>
                            </span>
                        </th>
                        <th>Ergebnis QC</th>
                        <th @click="sortBy('source_file')" class="sortable">
                            Source File
                            <span x-show="sortColumn === 'source_file'">
                                <span x-show="sortDirection === 'asc'">â–²</span>
                                <span x-show="sortDirection === 'desc'">â–¼</span>
                            </span>
                        </th>
                        <th>Complete</th>
                        <th>Valid</th>
                        <th>Done</th>
                    </tr>
                </thead>
                <tbody>
                    <template x-for="row in interleavedRows" :key="row.pair.case_id + '-' + row.type">
                        <tr class="pair-row"
                            :class="[row.type.includes('genomic') ? 'genomic' : 'clinical', 'priority-group-' + row.pair.priority_group]"
                            :data-case-id="row.pair.case_id"
                            :id="row.type === 'genomic' ? 'pair-genomic-' + row.pair.case_id : (row.type === 'clinical' ? 'pair-clinical-' + row.pair.case_id : '')">
                            <template x-if="row.type === 'genomic'">
                                <td class="case-id-cell" rowspan="2" x-text="row.pair.case_id"></td>
                            </template>
                            <template x-if="row.type === 'genomic-only' || row.type === 'clinical-only'">
                                <td class="case-id-cell" x-text="row.pair.case_id"></td>
                            </template>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td>
                                    <span x-text="row.pair.genomic.vorgangsnummer"></span>
                                    <span class="copy-btn" @click="copyToClipboard(row.pair.genomic.vorgangsnummer)"
                                        title="Copy to clipboard">ðŸ“‹</span>
                                </td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td>
                                    <span x-text="row.pair.clinical.vorgangsnummer"></span>
                                    <span class="copy-btn" @click="copyToClipboard(row.pair.clinical.vorgangsnummer)"
                                        title="Copy to clipboard">ðŸ“‹</span>
                                </td>
                            </template>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td>
                                    <span x-text="row.pair.genomic.meldebestaetigung"></span>
                                    <span class="copy-btn" @click="copyToClipboard(row.pair.genomic.meldebestaetigung)"
                                        title="Copy to clipboard">ðŸ“‹</span>
                                </td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td>
                                    <span x-text="row.pair.clinical.meldebestaetigung"></span>
                                    <span class="copy-btn" @click="copyToClipboard(row.pair.clinical.meldebestaetigung)"
                                        title="Copy to clipboard">ðŸ“‹</span>
                                </td>
                            </template>
                            <td x-text="row.type.includes('genomic') ? 'genomic' : 'clinical'"></td>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td x-text="row.pair.genomic.typ_der_meldung"></td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td x-text="row.pair.clinical.typ_der_meldung"></td>
                            </template>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td x-text="row.pair.genomic.indikationsbereich"></td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td x-text="row.pair.clinical.indikationsbereich"></td>
                            </template>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td x-text="row.pair.genomic.ergebnis_qc"></td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td x-text="row.pair.clinical.ergebnis_qc"></td>
                            </template>
                            <template x-if="row.type === 'genomic' || row.type === 'genomic-only'">
                                <td x-text="row.pair.genomic.source_file"></td>
                            </template>
                            <template x-if="row.type === 'clinical' || row.type === 'clinical-only'">
                                <td x-text="row.pair.clinical.source_file"></td>
                            </template>
                            <td>
                                <span class="complete-indicator" :class="row.pair.is_complete ? 'yes' : 'no'"></span>
                            </td>
                            <td>
                                <span class="valid-indicator" :class="row.pair.is_valid ? 'yes' : 'no'"></span>
                            </td>
                            <template x-if="row.type === 'genomic'">
                                <td class="done-cell" rowspan="2">
                                    <input type="checkbox" :checked="row.pair.is_done"
                                        :hx-post="'/api/done/' + row.pair.case_id"
                                        :hx-vals="JSON.stringify({done: !row.pair.is_done})"
                                        :hx-target="'#pair-genomic-' + row.pair.case_id" hx-swap="outerHTML"
                                        hx-indicator="#loading">
                                </td>
                            </template>
                            <template x-if="row.type === 'genomic-only' || row.type === 'clinical-only'">
                                <td class="done-cell">
                                    <span>â€”</span>
                                </td>
                            </template>
                        </tr>
                    </template>
                </tbody>
            </table>
            </div>
        </div>

        {% endif %}
    </div>


    <footer class="site-footer">
        <div class="container">
            <p>
                <em>MeldebstÃ¤tigungen Viewer</em>
                erstellt von
                <a href="https://github.com/BeneKenobi" target="_blank" rel="noopener noreferrer">@BeneKenobi</a>
                fÃ¼r das
                <a href="https://github.com/MHH-Humangenetik" target="_blank" rel="noopener noreferrer">Institut fÃ¼r
                    Humangenetik der MHH</a>
            </p>
        </div>
    </footer>

    <script id="pairs-data" type="application/json">
        {{ pairs | tojson | safe }}
    </script>

    <script>
        // WebSocket connection management
        class SyncWebSocket {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.reconnectDelay = 1000; // Start with 1 second
                this.maxReconnectDelay = 30000; // Max 30 seconds
                this.connectionId = null;
                this.isConnected = false;
                this.isReconnecting = false;
                this.heartbeatInterval = null;
                this.lastSyncTimestamp = null;
                
                // Connection status callbacks
                this.onConnectionChange = null;
                this.onSyncEvent = null;
                
                this.connect();
            }
            
            connect() {
                if (this.ws && (this.ws.readyState === WebSocket.CONNECTING || this.ws.readyState === WebSocket.OPEN)) {
                    return;
                }
                
                try {
                    // Construct WebSocket URL
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws?user_id=web_user_${Date.now()}`;
                    
                    console.log('Connecting to WebSocket:', wsUrl);
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = (event) => {
                        console.log('WebSocket connected');
                        this.isConnected = true;
                        this.isReconnecting = false;
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        
                        // Start heartbeat
                        this.startHeartbeat();
                        
                        // Subscribe to all events
                        this.subscribe(['*']);
                        
                        // Request sync for missed updates
                        if (this.lastSyncTimestamp) {
                            this.requestSync(this.lastSyncTimestamp);
                        }
                        
                        this.updateConnectionStatus('connected');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };
                    
                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event.code, event.reason);
                        this.isConnected = false;
                        this.stopHeartbeat();
                        
                        if (!this.isReconnecting && this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.scheduleReconnect();
                        } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                            this.updateConnectionStatus('failed');
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('error');
                    };
                    
                } catch (error) {
                    console.error('Failed to create WebSocket connection:', error);
                    this.scheduleReconnect();
                }
            }
            
            scheduleReconnect() {
                if (this.isReconnecting) return;
                
                this.isReconnecting = true;
                this.reconnectAttempts++;
                
                console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${this.reconnectDelay}ms`);
                this.updateConnectionStatus('reconnecting');
                
                setTimeout(() => {
                    this.isReconnecting = false;
                    this.connect();
                }, this.reconnectDelay);
                
                // Exponential backoff with jitter
                this.reconnectDelay = Math.min(
                    this.reconnectDelay * 2 + Math.random() * 1000,
                    this.maxReconnectDelay
                );
            }
            
            handleMessage(data) {
                console.log('WebSocket message received:', data);
                
                switch (data.type) {
                    case 'connection_established':
                        this.connectionId = data.connection_id;
                        console.log('Connection established with ID:', this.connectionId);
                        break;
                        
                    case 'heartbeat_response':
                        // Heartbeat acknowledged
                        break;
                        
                    case 'sync_event':
                        this.handleSyncEvent(data);
                        break;
                        
                    case 'sync_batch':
                        if (data.events && Array.isArray(data.events)) {
                            data.events.forEach(event => this.handleSyncEvent(event));
                        }
                        break;
                        
                    case 'error':
                        console.error('WebSocket error message:', data.message);
                        if (data.details && data.details.manual_refresh_required) {
                            this.updateConnectionStatus('degraded');
                        }
                        break;
                        
                    case 'connection_degraded':
                        console.warn('Connection degraded:', data.message);
                        this.updateConnectionStatus('degraded');
                        break;
                        
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }
            
            handleSyncEvent(event) {
                console.log('Sync event:', event);
                
                // Update last sync timestamp
                this.lastSyncTimestamp = event.timestamp;
                
                // Call sync event callback if set
                if (this.onSyncEvent) {
                    this.onSyncEvent(event);
                }
                
                // Handle different event types
                switch (event.event_type) {
                    case 'record_updated':
                        this.handleRecordUpdate(event);
                        break;
                    case 'record_added':
                        this.handleRecordAdded(event);
                        break;
                    case 'record_deleted':
                        this.handleRecordDeleted(event);
                        break;
                }
            }
            
            handleRecordUpdate(event) {
                // Update the UI for record changes
                const caseId = event.data.case_id || event.record_id;
                
                if (event.data.is_done !== undefined) {
                    // Status change - update the UI
                    this.updateRecordStatus(caseId, event.data);
                }
            }
            
            handleRecordAdded(event) {
                // New record added - refresh the page or add to table
                console.log('New record added:', event.record_id);
                // For now, just log - could implement dynamic table updates
            }
            
            handleRecordDeleted(event) {
                // Record deleted - remove from UI
                console.log('Record deleted:', event.record_id);
            }
            
            updateRecordStatus(caseId, data) {
                // Find and update the record in the Alpine.js data
                const alpineComponent = Alpine.$data(document.querySelector('[x-data]'));
                if (alpineComponent && alpineComponent.pairs) {
                    const pair = alpineComponent.pairs.find(p => p.case_id === caseId);
                    if (pair) {
                        // Update the pair data
                        pair.is_done = data.is_done;
                        pair.priority_group = data.priority_group || pair.priority_group;
                        
                        if (data.genomic && pair.genomic) {
                            pair.genomic.is_done = data.genomic.is_done;
                        }
                        if (data.clinical && pair.clinical) {
                            pair.clinical.is_done = data.clinical.is_done;
                        }
                        
                        console.log(`Updated record ${caseId} status to done=${data.is_done}`);
                        
                        // Mark as interacted to prevent reordering
                        if (alpineComponent.interactedPairs) {
                            alpineComponent.interactedPairs.add(caseId);
                        }
                    }
                }
            }
            
            startHeartbeat() {
                this.stopHeartbeat();
                this.heartbeatInterval = setInterval(() => {
                    if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
                        this.send({
                            type: 'heartbeat',
                            timestamp: new Date().toISOString()
                        });
                    }
                }, 30000); // Send heartbeat every 30 seconds
            }
            
            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            }
            
            subscribe(subscriptions) {
                if (this.isConnected) {
                    this.send({
                        type: 'subscribe',
                        subscriptions: subscriptions
                    });
                }
            }
            
            requestSync(lastSyncTimestamp) {
                if (this.isConnected) {
                    this.send({
                        type: 'sync_request',
                        last_sync_timestamp: lastSyncTimestamp
                    });
                }
            }
            
            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('Cannot send message - WebSocket not connected');
                }
            }
            
            updateConnectionStatus(status) {
                console.log('Connection status:', status);
                
                // Update UI connection indicator
                const indicator = document.getElementById('connection-status');
                if (indicator) {
                    indicator.className = `connection-status ${status}`;
                    
                    const statusText = {
                        'connected': 'Connected',
                        'connecting': 'Connecting...',
                        'reconnecting': 'Reconnecting...',
                        'error': 'Connection Error',
                        'failed': 'Connection Failed',
                        'degraded': 'Degraded Mode'
                    };
                    
                    indicator.textContent = statusText[status] || status;
                }
                
                // Call connection change callback if set
                if (this.onConnectionChange) {
                    this.onConnectionChange(status);
                }
            }
            
            disconnect() {
                this.stopHeartbeat();
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.isConnected = false;
                this.connectionId = null;
            }
        }
        
        // Initialize WebSocket connection
        let syncWebSocket = null;
        
        // Global copy function for onclick handlers (used by HTMX-swapped content)
        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    console.log('Copied to clipboard:', text);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                console.log('Copied to clipboard (fallback):', text);
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textArea);
        }

        function tableData() {
            let pairsData = [];
            try {
                const dataElement = document.getElementById('pairs-data');
                if (dataElement && dataElement.textContent) {
                    pairsData = JSON.parse(dataElement.textContent);
                    // Ensure it's an array
                    if (!Array.isArray(pairsData)) {
                        console.error('Pairs data is not an array:', pairsData);
                        pairsData = [];
                    }
                } else {
                    console.error('Pairs data element not found or empty');
                }
            } catch (error) {
                console.error('Error parsing pairs data:', error);
                pairsData = [];
            }

            // Pre-calculate initial sort positions before returning the component
            const initialSortPositions = new Map();
            try {
                pairsData.forEach((pair, index) => {
                    if (pair && pair.case_id) {
                        initialSortPositions.set(pair.case_id, index);
                    }
                });
            } catch (error) {
                console.error('Error calculating initial sort positions:', error);
            }

            return {
                pairs: pairsData,
                filter: '',
                sortColumn: 'priority_group',
                sortDirection: 'asc',
                interactedPairs: new Set(), // Track pairs that have been toggled
                initialSortPositions: initialSortPositions, // Store initial sort position for each pair

                get interleavedRows() {
                    const rows = [];
                    const sorted = this.filteredAndSorted;

                    sorted.forEach(pair => {
                        if (pair.genomic && pair.clinical && !this.htmxManagedPairs.has(pair.case_id)) {
                            // Complete pair: add both genomic and clinical rows
                            rows.push({ type: 'genomic', pair: pair });
                            rows.push({ type: 'clinical', pair: pair });
                        } else if (pair.genomic && !pair.clinical) {
                            // Genomic only
                            rows.push({ type: 'genomic-only', pair: pair });
                        } else if (!pair.genomic && pair.clinical) {
                            // Clinical only
                            rows.push({ type: 'clinical-only', pair: pair });
                        }
                    });

                    return rows;
                },

                get filteredAndSorted() {
                    try {
                        // Ensure pairs is an array and filter out malformed entries
                        const validPairs = Array.isArray(this.pairs) ? this.pairs.filter(pair => 
                            pair && typeof pair === 'object' && pair.case_id
                        ) : [];

                        let filtered = this.filter === ''
                            ? [...validPairs]  // Create a copy to avoid mutating original
                            : validPairs.filter(pair => {
                                try {
                                    // Search across all columns with safe property access
                                    const searchStr = this.filter.toLowerCase();
                                    const safeString = (str) => str && typeof str === 'string' ? str.toLowerCase() : '';
                                    
                                    return (
                                        safeString(pair.case_id).includes(searchStr) ||
                                        (pair.genomic && (
                                            safeString(pair.genomic.vorgangsnummer).includes(searchStr) ||
                                            safeString(pair.genomic.meldebestaetigung).includes(searchStr) ||
                                            safeString(pair.genomic.typ_der_meldung).includes(searchStr) ||
                                            safeString(pair.genomic.indikationsbereich).includes(searchStr) ||
                                            safeString(pair.genomic.ergebnis_qc).includes(searchStr) ||
                                            safeString(pair.genomic.source_file).includes(searchStr)
                                        )) ||
                                        (pair.clinical && (
                                            safeString(pair.clinical.vorgangsnummer).includes(searchStr) ||
                                            safeString(pair.clinical.meldebestaetigung).includes(searchStr) ||
                                            safeString(pair.clinical.typ_der_meldung).includes(searchStr) ||
                                            safeString(pair.clinical.indikationsbereich).includes(searchStr) ||
                                            safeString(pair.clinical.ergebnis_qc).includes(searchStr) ||
                                            safeString(pair.clinical.source_file).includes(searchStr)
                                        ))
                                    );
                                } catch (filterError) {
                                    console.error('Error filtering pair:', pair, filterError);
                                    return false; // Exclude malformed pairs from results
                                }
                            });

                        return filtered.sort((a, b) => {
                            try {
                                // Ensure both objects are valid
                                if (!a || !b || !a.case_id || !b.case_id) return 0;

                                // If either pair has been interacted with, use initial sort position
                                const aInteracted = this.interactedPairs.has(a.case_id);
                                const bInteracted = this.interactedPairs.has(b.case_id);

                                if (aInteracted || bInteracted) {
                                    // Use initial positions to maintain order
                                    const aPos = this.initialSortPositions.get(a.case_id) ?? 999999;
                                    const bPos = this.initialSortPositions.get(b.case_id) ?? 999999;
                                    return aPos - bPos;
                                }

                                // Neither interacted: use normal priority group sorting
                                const aPriority = typeof a.priority_group === 'number' ? a.priority_group : 999;
                                const bPriority = typeof b.priority_group === 'number' ? b.priority_group : 999;
                                
                                if (aPriority !== bPriority) {
                                    return aPriority - bPriority;
                                }

                                // Secondary sort: selected column
                                let aVal = this.getColumnValue(a, this.sortColumn);
                                let bVal = this.getColumnValue(b, this.sortColumn);

                                if (this.sortDirection === 'asc') {
                                    return aVal > bVal ? 1 : -1;
                                } else {
                                    return aVal < bVal ? 1 : -1;
                                }
                            } catch (sortError) {
                                console.error('Error sorting pairs:', a, b, sortError);
                                return 0; // Keep original order if sorting fails
                            }
                        });
                    } catch (error) {
                        console.error('Error in filteredAndSorted:', error);
                        return []; // Return empty array if everything fails
                    }
                },

                get totalCases() {
                    try {
                        return this.filteredAndSorted.length;
                    } catch (error) {
                        console.error('Error calculating total cases:', error);
                        return 0;
                    }
                },

                get readyPairs() {
                    try {
                        return this.filteredAndSorted.filter(pair => {
                            // Handle malformed pair objects
                            if (!pair || typeof pair !== 'object') return false;
                            const isComplete = pair.is_complete === true;
                            const isValid = pair.is_valid === true;
                            const isDone = pair.is_done === true;
                            return isComplete && isValid && !isDone;
                        }).length;
                    } catch (error) {
                        console.error('Error calculating ready pairs:', error);
                        return 0;
                    }
                },

                get donePairs() {
                    try {
                        return this.filteredAndSorted.filter(pair => {
                            // Handle malformed pair objects
                            if (!pair || typeof pair !== 'object') return false;
                            return pair.is_done === true;
                        }).length;
                    } catch (error) {
                        console.error('Error calculating done pairs:', error);
                        return 0;
                    }
                },

                getColumnValue(pair, column) {
                    try {
                        if (!pair || typeof pair !== 'object') return '';
                        if (column === 'case_id') return pair.case_id || '';
                        
                        // For other columns, use genomic record if available, otherwise clinical
                        const record = pair.genomic || pair.clinical;
                        if (!record || typeof record !== 'object') return '';
                        
                        const value = record[column];
                        return value && typeof value === 'string' ? value : '';
                    } catch (error) {
                        console.error('Error getting column value:', pair, column, error);
                        return '';
                    }
                },

                sortBy(column) {
                    if (this.sortColumn === column) {
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortColumn = column;
                        this.sortDirection = 'asc';
                    }
                },

                htmxManagedPairs: new Set(),

                updatePairDoneStatus(caseId, isDone) {
                    // Mark this pair as managed by HTMX
                    this.htmxManagedPairs.add(caseId);
                    // Mark this pair as interacted with (so it won't move on re-sort)
                    this.interactedPairs.add(caseId);
                    // Update the pair's done status in Alpine.js data
                    const pair = this.pairs.find(p => p.case_id === caseId);
                    if (pair) {
                        pair.is_done = isDone;
                        // Update priority group: 1 for complete not done, 3 for complete done
                        pair.priority_group = isDone ? 3 : 1;
                    }
                },

                isHtmxManaged(caseId) {
                    return this.htmxManagedPairs.has(caseId);
                }
            }
        }

        // Initialize WebSocket connection when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Only initialize WebSocket if we have data (not an error page)
            const dataElement = document.getElementById('pairs-data');
            if (dataElement && dataElement.textContent) {
                syncWebSocket = new SyncWebSocket();
                
                // Set up connection status callback
                syncWebSocket.onConnectionChange = function(status) {
                    console.log('Connection status changed to:', status);
                    
                    if (status === 'degraded' || status === 'failed') {
                        // Show manual refresh notice
                        const existingNotice = document.querySelector('.connection-notice');
                        if (!existingNotice) {
                            const notice = document.createElement('div');
                            notice.className = 'connection-notice';
                            notice.innerHTML = `
                                <p><strong>Connection Issue:</strong> Real-time updates are unavailable. 
                                <button onclick="window.location.reload()">Refresh Page</button></p>
                            `;
                            document.querySelector('.container').insertBefore(notice, document.querySelector('.filter-and-stats-container'));
                        }
                    }
                };
                
                // Set up sync event callback
                syncWebSocket.onSyncEvent = function(event) {
                    console.log('Received sync event:', event);
                    // Additional sync event handling can be added here
                };
            }
        });

        // Listen for HTMX beforeSwap event to remove Alpine.js rendered rows
        document.body.addEventListener('htmx:beforeSwap', function (event) {
            // Check if this was a done status update
            if (event.detail.target && event.detail.target.id && event.detail.target.id.startsWith('pair-genomic-')) {
                const caseId = event.detail.target.id.replace('pair-genomic-', '');
                // Find and remove the Alpine.js rendered clinical row
                const clinicalRows = document.querySelectorAll(`tr.clinical[data-case-id="${caseId}"]`);
                clinicalRows.forEach(row => {
                    // Only remove if it doesn't have an ID (Alpine.js rendered)
                    if (!row.id) {
                        row.remove();
                    }
                });
            }
        });

        // Listen for HTMX afterSwap event to update Alpine.js data
        document.body.addEventListener('htmx:afterSwap', function (event) {
            // Check if this was a done status update
            if (event.detail.target && event.detail.target.id && event.detail.target.id.startsWith('pair-genomic-')) {
                const caseId = event.detail.target.id.replace('pair-genomic-', '');
                // Extract the new done status from the swapped content
                const checkbox = event.detail.target.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    const isDone = checkbox.checked;
                    // Get Alpine.js component and update data
                    const alpineComponent = Alpine.$data(document.querySelector('[x-data]'));
                    if (alpineComponent && alpineComponent.updatePairDoneStatus) {
                        alpineComponent.updatePairDoneStatus(caseId, isDone);
                    }
                }
            }
        });
    </script>
</body>

</html>